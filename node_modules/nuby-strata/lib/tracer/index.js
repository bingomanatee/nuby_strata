var util = require('util');
var _ = require('./../../node_modules/underscore');

function Tracer(name) {
    this.name = name;
    this.history = [];
}

Tracer.prototype = {
    _flat:function (value, out, prefix, old_objs) {

        if (_.isObject(value)) {
            var recurs = false;
            old_objs.forEach(function (o) {
                if (o === value) {
                    recurs = true;
                }
            });
            if (recurs) {
                out[prefix.join('::')] = 'recurs'
            } else {
                old_objs.push(value);
                for (var p in value) {
                    switch (p) {
                        case 'tracer':
                            continue;
                            break;

                        case '_action':
                            continue;
                            break;
                        default:
                            var prefix_path = prefix.slice(0);
                            prefix_path.push(p);
                            var v = value[p];
                            if (_.isObject(v)) {
                                this._flat(v, out, prefix_path, old_objs);
                            } else {
                                out[prefix_path.join('::')] = v;
                            }

                    }
                }
            }
        }
    },
    log:[],
    flat:function (value) {
        var out = {};
        var old_objs = [];
        this._flat(value, out, [], old_objs);
        return out;
    },
    diff:function (value, last_value) {
        var val = this.flat(value);
        var last_val = this.flat(last_value);

        var status = {
            new:{},
            changed:{},
            removed:{}
        }

        for (var prop in val) {
            var v = val[prop];
            if (typeof v == 'object') continue;
            if (last_val.hasOwnProperty(prop)) {
                var lv = last_val[prop];
                if (lv != v) {
                    status.changed[prop] = util.format("%s << %s", v, lv);
                }
                delete last_val[prop];
            } else {
                status.new[prop] = v;
            }
        }

        for (var prop in last_val) {
            status.removed[prop] = last_val[prop];
        }

        return status;
    },

    say:function (data, ctx) {
        var i = util.inspect(data);
        console.log("=========== TRACE %s =========", ctx);
        console.log(i);
        console.log('========== END TRACE %s ========', ctx);
        this.log.push({ctx:ctx, data:i});
    }
}

Tracer.prototype.decirculate = function (item) {
    var target = {out:{}};

    Tracer.prototype._decirculate(target, 'out', item, []);
    return target.out;
}

Tracer.prototype._decirculate = function (target, param, item, objs) {
    var new_item = {};
    var tr = this;
    var new_item;

    if (_.isArray(item)) {
        new_item = [];
        item.forEach(function (v, i) {
            tr._decirculate(new_item, i, v, objs);
        });
    } else if (_.isObject(item)) {
        if (_.contains( objs, item)) {
            new_item = '[circular]';
        } else {
            new_item = {};

            var objs_i = objs.slice(0);
            objs_i.push(item);

            for (var p in item) {
                tr._decirculate(new_item, p, item[p], objs_i);
            }

        }
    } else {
        new_item = item;
    }
    target[param] = new_item;
}

Tracer.prototype.trace = function (value, ctx) {
    var rvalue = this.decirculate(value);
  //  console.log('tracing %s', util.inspect(rvalue));
    if (this.history.length > 0) {
        var last_value = this.history[this.history.length - 1].value;
        var diff_value = this.diff(rvalue, last_value);
        this.say(diff_value, ctx);

    } else {
        this.say(value, ctx);
    }
    this.history.push({ctx:ctx, value:rvalue});
}

module.exports = Tracer;