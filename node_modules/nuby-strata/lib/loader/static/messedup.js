var path = require("path"),
    fs = require("fs"),
    proper_path = require('./../../support/proper_path'),
    util = require('util'),
    mime = require("./../../../node_modules/strata/node_modules/mime");

/**
 * Adapted from the strata static file server, this allows the appliation
 * to dynamically set and remove static configurations from its service.
 *
 * Each item in the static_resources collection needs the following profile
 *
 *     {
 *       prefix: string -- ex.: "/public" -- qualifies the path to be checked.
 *                         note the prefix can be virtual - the file (below)
 *                         need not include the prefix.
 *      path:    string -- ex: "/var/www" -- an absolute system
 *                         file path to files you want to serve up statically.
 *      index:   array --  ex: ["index.html", "index.htm"]
 *                         the default file to serve if a static directory is asked for.
 *      proper: boolean (optional)
 *                         indicates that prefix and path has been filtered.
 *
 *
 * @TODO: a hash of file hits - possibly preloaded - to optimize return time.
 */
module.exports = {
    create_resource:function (prefix, real_path, index) {
        if (!index){
            index = [];
        }
        //@TODO -- check uniqueness of prefix
        prefix = proper_path(prefix);
        real_path = proper_path(real_path);

        return {
            prefix:prefix,
            path:real_path,
            index:index,
            proper:true
        };
    },

    find_file:function (search_file, resources) {
        search_file = proper_path(search_file);
        var found = false;
        var real_resource_path = '';
        var rrp_stat = null;
        var path_checked = false;

        var i = 0;
        while ((!found) && (!path_checked) && (i < resources.length)) {
            var resource = resources[i];
            var resource_prefix = resource.prefix;
            /**
             *
             *   the folder that the resouces PRETEND to be in
             *   this path must be the start of any URL to a resource for it to be considered to be
             *   governed by this resource.
             *
             *   By insisting that each resource group has its own prefix,
             *   you avoid potential unwanted overlap of resource files between resources.
             *
             **/

            if (!resource.proper) {
                resource_prefix = proper_path(resource_prefix);
                resource.prefix = resource_prefix;
                resource.path = proper_path(resource.path);
                resource.proper = true;
            }

            console.log('resource_prefix = %s', resource_prefix);

            if (search_file.substring(0, resource_prefix.length) == resource_prefix) {
                var path_checked = true;
                /**
                 *       this should be the last while check --
                 *       if you have found the right preix, why check the others?
                 */

                var resource_path = resource.path;
                /**
                 * files is an absolute path to a set of resouces to be served up.
                 */

                if (resource_prefix == '/') {
                    real_resource_path = resource_path + search_file;
                } else {
                    var resource_suffix = search_file.substring(resource_prefix.length); // only check the part of the file
                    // that is AFTER the resource path.

                    real_resource_path = resource_path + resource_suffix;
                }
                /**
                 * You can't use async file checks because that might mean checking more than one path
                 * just because a single path check that would have told you "You're done" has not completed.
                 */

                if (path.existsSync(real_resource_path)) {

                    rrp_stat = fs.statSync(real_resource_path);

                    if (rrp_stat.isFile()) {
                        found = true;
                    } else if (rrp_stat.isDirectory() && resource.hasOwnProperty('index')) {
                        console.log('index == %s', util.inspect(resource.index));
                        for (var i = 0, len = resource.index.length; !found && i < len; ++i) {
                            var dir_real_resource_path = path.join(real_resource_path, resource.index[i]);

                            if (path.existsSync(dir_real_resource_path)) {
                                var d_stats = fs.statSync(dir_real_resource_path);
                                if (d_stats.isFile()) {
                                    found = true;
                                    real_resource_path = dir_real_resource_path;
                                    rrp_stat = d_stats;
                                }
                            }
                            /**
                             * note - if a directory is requisitioned, only a directory
                             * with a valid index is considered valid.
                             */
                        } // end for
                    } // end if path type
                }
            } // end if path match;
        } // end while

        if (found){
            return [real_resource_path, rrp_stat];
        } else {
            return false;
        }
    },

    serve_static_files:function (app, context) {

        return function nuby_static(env, callback) {
            var url_resource_path = unescape(env.pathInfo);

            var found = module.exports.find_file(url_resource_path, context.static_resources);

            if (found) {
                sendFile(callback, found[0], found[1]);
            } else {
                console.log('did not find static resource %s', url_resource_path);
                app(env, callback);
            }
        } // end returned function
    } // end serve function
} // end exports

function sendFile(callback, path, stats) {
    callback(200, {
        "Content-Type":mime.lookup(path),
        "Content-Length":stats.size.toString(),
        "Last-Modified":stats.mtime.toUTCString()
    }, fs.createReadStream(path));
}
