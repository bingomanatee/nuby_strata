var path = require("path"),
    fs = require("fs"),
    util = require('util'),
    mime = require("./../../../node_modules/strata/node_modules/mime"),
    strata = require("./index"),
    _ = require('./../../../node_modules/underscore');

var _resources = [];
/**
 * A middleware for serving files efficiently from the given `root` directory
 * according to path contained in the pathInfo environment variable. The `index`
 * argument specifies what file will be served if the request targets a
 * directory. It may be a single filename (e.g. "index.html") or an array of
 * names to be tried in order (e.g. ["index.html", "index.htm"]).
 *
 * If a matching file cannot be found, the request is forwarded to the
 * downstream app. Otherwise, the file is streamed through to the callback.
 */
module.exports = {
    register:function (res, index, prefix) {
        if (_.isArray(res)) {
            return res.forEach(function (r) {
                module.exports.register(r);
            })
        } else if (_.isString(res)) {
            if (_.isString(index)) {
                index = [index];
            }
            res = {
                root:res,
                index:index || [],
                prefix:prefix || ''
            }
        }

        _resources.push(res);
    },
    create:function (app, res) {
        if (res) {
            module.exports.register(res);
        }

        return function (env, callback) {
            _static_search(app, env, callback);
        }
    }
}

function _static_search(app, env, callback) {

    var found = false;

    _static_search_res(app, env, callback, 0);
}

function _static_search_res(app, env, callback, res_index) {
    if (res_index >= _resources.length) {
        return app(env, callback);
    }

    var pathInfo = unescape(env.pathInfo);

    if (!pathInfo) {
        return app(env, callback);
    }

    console.log('reading resource %s of %s for %s',
        res_index, util.inspect(_resources), pathInfo);
    var res = _resources[res_index];

    var root = res.root;
    var index = res.index;
    var fullPath = path.join(root, pathInfo);
    var prefix = res.prefix;

    if (prefix) {
        console.log('searching for prefix %s', prefix);
        if (pathInfo.substring(0, prefix.length) == prefix) {
            console.log('resource path found!!! %s in %s', prefix, pathInfo);
            var subPathInfo = pathInfo.substring(prefix.length);
            fullPath = root + subPathInfo;
            path.exists(fullPath, function (exists) {
                _static_search_res_exists(exists, fullPath, index, res_index, app, env, callback);
            });
        } else {
            return  _static_search_res(app, env, callback, res_index + 1);
        }
    } else {
        console.log('searching for full path %s', fullPath);
        path.exists(fullPath, function (exists) {
            _static_search_res_exists(exists, fullPath, index, res_index, app, env, callback);
        });
    }
}

function _static_search_res_exists(exists, fullPath, index, res_index, app, env, callback) {


    if (exists) {
        fs.stat(fullPath, function (err, stats) {
            if (err) {
                return strata.handleError(err, env, callback);
            }

            if (stats.isFile()) {
                sendFile(callback, fullPath, stats);
            } else if (stats.isDirectory() && index) {
                _static_dir(fullPath, index, app, env, callback);
            } else {
                app(env, callback);
            }
        });
    } else {
        ++res_index;
        console.log('searching for %s; going to the next index %s', fullPath, res_index);
        _static_search_res(app, env, callback, res_index);
    }
}

function _static_dir(fullPath, index, app, env, callback) {
    console.log('_static_dir(%s)', fullPath);
    // If the request targets a directory check all index
    // files to see if we can serve any of them.
    var indexExists = {};

    function sendFirstExisting() {
        var found = false,
            indexPath;

        for (var i = 0, len = index.length; !found && i < len; ++i) {
            indexPath = path.join(fullPath, index[i]);

            if (indexExists[indexPath]) {
                fs.stat(indexPath, function (err, stats) {
                    if (err) {
                        return strata.handleError(err, env, callback);
                    }

                    sendFile(callback, indexPath, stats);
                });

                found = true;
            }
        }

        if (!found) {
            console.log('cannot find path %s', fullPath);
            app(env, callback);
        }
    }

    var checked = 0;

    for (var i = 0, len = index.length; i < len; ++i) {
        (function (indexPath) {
            path.exists(indexPath, function (exists) {
                indexExists[indexPath] = exists;
                checked += 1;

                if (checked == len) {
                    sendFirstExisting();
                }
            });
        })(path.join(fullPath, index[i]));
    }
}


function __search() {

    if (typeof root != "string") {
        throw new strata.Error("Invalid root directory");
    }

    if (!path.existsSync(root)) {
        throw new strata.Error('Directory "' + root + '" does not exist');
    }

    if (!fs.statSync(root).isDirectory()) {
        throw new strata.Error('"' + root + '" is not a directory');
    }

    if (index && typeof index == "string") {
        index = [index];
    }

    return
}

function sendFile(callback, path, stats) {
    callback(200, {
        "Content-Type":mime.lookup(path),
        "Content-Length":stats.size.toString(),
        "Last-Modified":stats.mtime.toUTCString()
    }, fs.createReadStream(path));
}
