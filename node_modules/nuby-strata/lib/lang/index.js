var fs = require('fs');
var _ = require('underscore');
var util = require('util');

function Lang(dict_path, lang) {
    this._al = null,
        this._terms = {},
        this._dict = dict_path;
    this._init_al();
    if (lang) {
        this.set_lang(lang);
    }
}

Lang.prototype = {

    avail_langs:function () {
        return this._al;
    },

    set_dict:function (d) {
        d = d.replace(/\/$/, '');
        this._dict = d;
    },

    lang_exists:function (lang_name, throw_err, ctx) {
        if (_.contains(this.avail_langs(), lang_name)) {
            return true;
        } else if (throw_err) {
            if (ctx) {
                throw new Error(ctx.replace(/%lang%/g, lang_name).replace(/%dir%/g, __dirname));
            } else {
                throw new Error(util.format('%s: attempt to use lanugage %s in dict path %s failed.', __dirname, lang_name, this._dict));
            }
        } else {
            return false;
        }
    },

    set_lang:function (lang_name) {
        if (this.lang_exists(lang_name, true)) {
            this.lang = lang_name;
            this._load_lang(lang_name);
        }
    },

    term:function (t, lang_name, no_default) {
        if (!lang_name) {
            lang_name = this.lang;
        }

        if (this.lang_exists(lang_name, true)) {
            if (!this._terms.hasOwnProperty(lang_name)) {
                this._load_lang(lang_name);
            }
            if (this._terms[lang_name].hasOwnProperty(t)) {
                return this._terms[lang_name][t];
            } else if (no_default) {
                throw new Error(util.format('%s: cannot find term %s in language %s', __dirname, t, lang_name));
            } else if (lang_name != this.lang) {
                return '&laquo' + this.term(t) + '&raquo';
            } else {
                throw new Error(util.format('%s: cannot find term %s in language %s', __dirname, t, lang_name));
            }
        }
    },

    _load_lang:function (lang_name) {
        var txt = fs.readFileSync(this._dict + '/' + lang_name + '/terms.txt').toString();
        var terms = txt.split("\n");
        delete txt;
        var self = this;
        if (!this._terms.hasOwnProperty(lang_name)) {
            this._terms[lang_name] = {};
        }
        terms.forEach(function (term) {
            var k = term.indexOf('>');
            if (k > 0) {
                var term_name = term.substr(0, k);
                var meaning = term.substr(k + 1);
              //  console.log('terms: %s, %s', util.inspect(self._terms), lang_name);
                self._terms[lang_name][term_name] = meaning;
            }
        });
    },
//@TODO: integrate ondir;
    _init_al:function () {
    //    console.log('_init_al:: checking %s', this._dict);
        var items = fs.readdirSync(this._dict);
        this._al = [];
        var self = this;
        items.forEach(function (item) {
            var lang_path = self._dict + '/' + item;
          //  console.log('checking lang path %s', lang_path);
            if (fs.statSync(lang_path).isDirectory()) {
             //   console.log('adding lang_path %s', lang_path);
                self._al.push(item);
            } else {
       //         console.log('skipping no-dir %s', lang_path);
            }
        });
      //  console.log('available langs: %s', util.inspect(this._al));
    }

}

module.exports = {
    Lang:Lang,
    create:function (dict_path, default_lang) {
        return new Lang(dict_path, default_lang);
    }
}